// Copyright 2016 - 2026 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.24.0 or later.

package excelize

import (
	"bytes"
	"encoding/base64"
	"encoding/binary"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/richardlehane/mscfb"
	"github.com/stretchr/testify/assert"
)

func TestEncrypt(t *testing.T) {
	// Test decrypt spreadsheet with incorrect password
	_, err := OpenFile(filepath.Join("test", "encryptSHA1.xlsx"), Options{Password: "passwd"})
	assert.EqualError(t, err, ErrWorkbookPassword.Error())
	// Test decrypt spreadsheet with password
	f, err := OpenFile(filepath.Join("test", "encryptSHA1.xlsx"), Options{Password: "password"})
	assert.NoError(t, err)
	cell, err := f.GetCellValue("Sheet1", "A1")
	assert.NoError(t, err)
	assert.Equal(t, "SECRET", cell)
	assert.NoError(t, f.Close())
	// Test decrypt spreadsheet with unsupported encrypt mechanism
	raw, err := os.ReadFile(filepath.Join("test", "encryptAES.xlsx"))
	assert.NoError(t, err)
	raw[2050] = 3
	_, err = Decrypt(raw, &Options{Password: "password"})
	assert.Equal(t, ErrUnsupportedEncryptMechanism, err)

	// Test encrypt spreadsheet with invalid password
	assert.EqualError(t, f.SaveAs(filepath.Join("test", "Encryption.xlsx"), Options{Password: strings.Repeat("*", MaxFieldLength+1)}), ErrPasswordLengthInvalid.Error())
	// Test encrypt spreadsheet with new password
	assert.NoError(t, f.SaveAs(filepath.Join("test", "Encryption.xlsx"), Options{Password: "passwd"}))
	assert.NoError(t, f.Close())
	f, err = OpenFile(filepath.Join("test", "Encryption.xlsx"), Options{Password: "passwd"})
	assert.NoError(t, err)
	cell, err = f.GetCellValue("Sheet1", "A1")
	assert.NoError(t, err)
	assert.Equal(t, "SECRET", cell)
	// Test remove password by save workbook with options
	assert.NoError(t, f.Save(Options{Password: ""}))
	assert.NoError(t, f.Close())

	doc, err := mscfb.New(bytes.NewReader(raw))
	assert.NoError(t, err)
	encryptionInfoBuf, encryptedPackageBuf, err := extractPart(doc)
	assert.NoError(t, err)
	binary.LittleEndian.PutUint64(encryptionInfoBuf[20:32], uint64(0))
	_, err = standardDecrypt(encryptionInfoBuf, encryptedPackageBuf, &Options{Password: "password"})
	assert.NoError(t, err)
	_, err = decrypt(nil, nil, nil)
	assert.EqualError(t, err, "crypto/aes: invalid key size 0")
	_, err = agileDecrypt(encryptionInfoBuf, MacintoshCyrillicCharset, &Options{Password: "password"})
	assert.EqualError(t, err, "XML syntax error on line 1: invalid character entity &0 (no semicolon)")
	_, err = convertPasswdToKey("password", nil, Encryption{
		KeyEncryptors: KeyEncryptors{KeyEncryptor: []KeyEncryptor{
			{EncryptedKey: EncryptedKey{KeyData: KeyData{SaltValue: "=="}}},
		}},
	})
	assert.EqualError(t, err, "illegal base64 data at input byte 0")
	_, err = createIV([]byte{0}, Encryption{KeyData: KeyData{SaltValue: "=="}})
	assert.EqualError(t, err, "illegal base64 data at input byte 0")
	// Test error handling for EncryptionInfo parse failure
	compoundFile := &cfb{
		paths:   []string{"Root Entry/"},
		sectors: []sector{{name: "Root Entry", typeID: 5}},
	}
	compoundFile.put("EncryptionInfo", []byte{})
	_, err = OpenReader(bytes.NewReader(compoundFile.write()))
	assert.Equal(t, ErrWorkbookFileFormat, err)
	// Test error handling for EncryptedPackage parse failure
	compoundFile = &cfb{
		paths:   []string{"Root Entry/"},
		sectors: []sector{{name: "Root Entry", typeID: 5}},
	}
	encryptionInfo := make([]byte, 100)
	binary.LittleEndian.PutUint16(encryptionInfo[:2], 4)
	binary.LittleEndian.PutUint16(encryptionInfo[2:4], 4)
	compoundFile.put("EncryptionInfo", encryptionInfo)
	compoundFile.put("EncryptedPackage", []byte{})
	_, err = OpenReader(bytes.NewReader(compoundFile.write()))
	assert.Equal(t, ErrWorkbookFileFormat, err)
	// Test createIV when iv length is less than block size
	_, err = createIV(0, Encryption{
		KeyData: KeyData{
			HashAlgorithm: "md5",
			BlockSize:     32,
			SaltValue:     base64.StdEncoding.EncodeToString([]byte("")),
		},
	})
	assert.NoError(t, err)
	// Test decryptPackage error with padding
	input := make([]byte, 18)
	binary.LittleEndian.PutUint64(input[:8], 10)
	for i := 8; i < 18; i++ {
		input[i] = byte(i)
	}
	_, err = decryptPackage(make([]byte, 32), input, Encryption{
		KeyData: KeyData{
			HashAlgorithm: "sha256",
			BlockSize:     16,
			SaltValue:     base64.StdEncoding.EncodeToString([]byte("")),
		},
	})
	assert.NoError(t, err)
	// Test IV creation error with invalid salt
	input = make([]byte, 4104)
	binary.LittleEndian.PutUint64(input[:8], 4096)
	_, err = decryptPackage(make([]byte, 32), input, Encryption{
		KeyData: KeyData{
			HashAlgorithm: "sha256",
			BlockSize:     16,
			SaltValue:     "==",
		},
	})
	assert.Error(t, err)
	// Test decrypt error with invalid key
	_, err = decryptPackage([]byte{}, input, Encryption{
		KeyData: KeyData{
			HashAlgorithm: "sha256",
			BlockSize:     16,
			SaltValue:     base64.StdEncoding.EncodeToString([]byte("")),
		},
	})
	assert.Error(t, err)
	// Test put with path that is a prefix of name
	compoundFile = &cfb{
		paths:   []string{"Root Entry/"},
		sectors: []sector{{name: "Root Entry", typeID: 5}},
	}
	compoundFile.put("Root Entry/Test", []byte(""))
	compoundFile = &cfb{
		paths:   []string{"Root"},
		sectors: []sector{{name: "Root", typeID: 5}},
	}
	compoundFile.put("Test", []byte(""))
	// Test compare function with different scenarios
	compoundFile = &cfb{}
	assert.Equal(t, -1, compoundFile.compare("Root/A", "Root/B"))
	assert.Equal(t, 1, compoundFile.compare("Root/B", "Root/A"))
	assert.Equal(t, -1, compoundFile.compare("Root", "Root/Child"))
	// Test prepare with typeID == 0 sector
	compoundFile = &cfb{
		paths: []string{"Root Entry/", "Skip/", "Valid/"},
		sectors: []sector{
			{name: "Root Entry", typeID: 5},
			{name: "Skip", typeID: 0},
			{name: "Valid", typeID: 2},
		},
	}
	compoundFile.prepare()
	// Test locate with FATSectors incrementing but staying <= 109
	compoundFile = &cfb{
		paths:   []string{"Root Entry/"},
		sectors: []sector{{name: "Root Entry", typeID: 5, content: []byte{}}},
	}
	numFiles := 1533
	for i := range numFiles {
		name := strings.Repeat("F", i%50+1)
		compoundFile.paths = append(compoundFile.paths, name+"/")
		compoundFile.sectors = append(compoundFile.sectors, sector{
			name:    name,
			typeID:  2,
			content: make([]byte, 4096),
		})
	}
	compoundFile.locate()
	// Test writeDirectoryEntry with empty clsID
	compoundFile = &cfb{
		paths: []string{"Root Entry/", "File1/"},
		sectors: []sector{
			{name: "Root Entry", typeID: 5, content: []byte{}, clsID: headerCLSID},
			{name: "File1", typeID: 2, content: []byte("test"), clsID: []byte{}},
		},
	}
	compoundFile.stream = make([]byte, 10000)
	compoundFile.writeDirectoryEntry([]int{1, 0, 1, 0, 1, 0, 0, 0})
}

func TestEncryptionMechanism(t *testing.T) {
	mechanism, err := encryptionMechanism([]byte{3, 0, 3, 0})
	assert.Equal(t, mechanism, "extensible")
	assert.EqualError(t, err, ErrUnsupportedEncryptMechanism.Error())
	_, err = encryptionMechanism([]byte{})
	assert.EqualError(t, err, ErrUnknownEncryptMechanism.Error())
}

func TestHashing(t *testing.T) {
	assert.Equal(t, hashing("unsupportedHashAlgorithm", []byte{}), []byte(nil))
}

func TestGenISOPasswdHash(t *testing.T) {
	for hashAlgorithm, expected := range map[string][]string{
		"MD4":     {"2lZQZUubVHLm/t6KsuHX4w==", "TTHjJdU70B/6Zq83XGhHVA=="},
		"MD5":     {"HWbqyd4dKKCjk1fEhk2kuQ==", "8ADyorkumWCayIukRhlVKQ=="},
		"SHA-1":   {"XErQIV3Ol+nhXkyCxrLTEQm+mSc=", "I3nDtyf59ASaNX1l6KpFnA=="},
		"SHA-256": {"7oqMFyfED+mPrzRIBQ+KpKT4SClMHEPOZldliP15xAA=", "ru1R/w3P3Jna2Qo+EE8QiA=="},
		"SHA-384": {"nMODLlxsC8vr0btcq0kp/jksg5FaI3az5Sjo1yZk+/x4bFzsuIvpDKUhJGAk/fzo", "Zjq9/jHlgOY6MzFDSlVNZg=="},
		"SHA-512": {"YZ6jrGOFQgVKK3rDK/0SHGGgxEmFJglQIIRamZc2PkxVtUBp54fQn96+jVXEOqo6dtCSanqksXGcm/h3KaiR4Q==", "p5s/bybHBPtusI7EydTIrg=="},
	} {
		hashValue, saltValue, err := genISOPasswdHash("password", hashAlgorithm, expected[1], int(sheetProtectionSpinCount))
		assert.NoError(t, err)
		assert.Equal(t, expected[0], hashValue)
		assert.Equal(t, expected[1], saltValue)
	}
}
