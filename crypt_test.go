// Copyright 2016 - 2021 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to
// and read from XLSX / XLSM / XLTM files. Supports reading and writing
// spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later. Supports
// complex components by high compatibility, and provided streaming API for
// generating or reading data from a worksheet with huge amounts of data. This
// library needs Go version 1.15 or later.

package excelize

import (
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestEncrypt(t *testing.T) {
	f, err := OpenFile(filepath.Join("test", "encryptSHA1.xlsx"), Options{Password: "password"})
	assert.NoError(t, err)
	assert.EqualError(t, f.SaveAs(filepath.Join("test", "BadEncrypt.xlsx"), Options{Password: "password"}), ErrEncrypt.Error())
	assert.NoError(t, f.Close())
}

func TestEncryptionMechanism(t *testing.T) {
	mechanism, err := encryptionMechanism([]byte{3, 0, 3, 0})
	assert.Equal(t, mechanism, "extensible")
	assert.EqualError(t, err, ErrUnsupportEncryptMechanism.Error())
	_, err = encryptionMechanism([]byte{})
	assert.EqualError(t, err, ErrUnknownEncryptMechanism.Error())
}

func TestHashing(t *testing.T) {
	assert.Equal(t, hashing("unsupportHashAlgorithm", []byte{}), []uint8([]byte(nil)))
}

func TestGenISOPasswordHash(t *testing.T) {
	/*
		WorkbookProtection:
			<workbookProtection
				workbookAlgorithmName="SHA-512"
				workbookHashValue="7JIH3q8xjBAG1xGKnS8Y1wUQnrmPXkov7DVCTMa5HKhG413knffE5aWIXF7RFiP31+SXm0qTn/xcTDVfkk3V7g=="
				workbookSaltValue="1oQNxuoY2xYR2Gu5UM8Xlw=="
				workbookSpinCount="100000"
				lockStructure="1"
			/>
		WorksheetProtection:
			<sheetProtection
				algorithmName="SHA-512"
				hashValue="R2/6Z96R9jO6DiptdOXU2+tZdm8/iRKkWr61+4Bz6BsDccvJ7y8R5BJsTjRDog7BXcMKsvrBIm+B4VGkAgZ2DA=="
				saltValue="CDWF0uq3twTX0pCE0eI9Pg=="
				spinCount="100000"
				sheet="1"
				...
			/>
	*/

	// test1
	// given salt value: WorkbookProtection
	workbookProtectionSaltValue := "1oQNxuoY2xYR2Gu5UM8Xlw=="
	workbookProtectionHashValue := "7JIH3q8xjBAG1xGKnS8Y1wUQnrmPXkov7DVCTMa5HKhG413knffE5aWIXF7RFiP31+SXm0qTn/xcTDVfkk3V7g=="
	resultWb, _ := genISOPasswordHash(saltHashData{
		Password:      "excelizeAwesome",
		AlgorithmName: "SHA-512",
		SpinCount:     1e5,
	}, workbookProtectionSaltValue)
	assert.Equal(t, resultWb.HashValue, workbookProtectionHashValue, "given salt value: WorkbookProtection")

	// test2
	// given salt value: WorksheetProtection
	worksheetProtectionSaltValue := "CDWF0uq3twTX0pCE0eI9Pg=="
	worksheetProtectionHashValue := "R2/6Z96R9jO6DiptdOXU2+tZdm8/iRKkWr61+4Bz6BsDccvJ7y8R5BJsTjRDog7BXcMKsvrBIm+B4VGkAgZ2DA=="
	resultWsht, _ := genISOPasswordHash(saltHashData{
		Password:      "excelizeAwesome",
		AlgorithmName: "SHA-512",
		SpinCount:     1e5,
	}, worksheetProtectionSaltValue)
	assert.Equal(t, resultWsht.HashValue, worksheetProtectionHashValue, "given salt value: WorksheetProtection")

	// test3
	// no given salt value
	resultRandomSalt, _ := genISOPasswordHash(saltHashData{
		Password:      "excelizeAwesome",
		AlgorithmName: "SHA-512",
		SpinCount:     1e5,
	})
	resultRandomSaltMatch, _ := genISOPasswordHash(saltHashData{
		Password:      "excelizeAwesome",
		AlgorithmName: "SHA-512",
		SpinCount:     1e5,
	}, resultRandomSalt.SaltValue)
	assert.Equal(t, resultRandomSalt.HashValue, resultRandomSaltMatch.HashValue, "no given salt value")

	var err error

	// given salt value: "", should pass
	resultRandomSaltMatch, err = genISOPasswordHash(saltHashData{
		Password:      "password",
		AlgorithmName: "SHA-512",
		SpinCount:     1e5,
	}, "")
	assert.NoError(t, err)
	assert.NotEqual(t, "", resultRandomSaltMatch.SaltValue)

	// password length invalid, should raise ErrPasswordLengthInvalid
	_, err = genISOPasswordHash(saltHashData{
		Password:      "",
		AlgorithmName: "SHA-512",
		SpinCount:     1e5,
	})
	assert.EqualError(t, err, ErrPasswordLengthInvalid.Error())

	// password length invalid - over length, should raise ErrPasswordLengthInvalid
	overLengthPassword := "password"
	for len(overLengthPassword) <= 255 {
		overLengthPassword = overLengthPassword + "d"
	}
	_, err = genISOPasswordHash(saltHashData{
		Password:      overLengthPassword,
		AlgorithmName: "SHA-512",
		SpinCount:     1e5,
	})
	assert.EqualError(t, err, ErrPasswordLengthInvalid.Error())
}
