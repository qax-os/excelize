// Copyright 2016 - 2025 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.23 or later.

package excelize

import (
	"fmt"
	"path/filepath"
	"slices"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

var MacintoshCyrillicCharset = []byte{0x8F, 0xF0, 0xE8, 0xE2, 0xE5, 0xF2, 0x20, 0xEC, 0xE8, 0xF0}

func TestSetAppProps(t *testing.T) {
	f, err := OpenFile(filepath.Join("test", "Book1.xlsx"))
	if !assert.NoError(t, err) {
		t.FailNow()
	}
	assert.NoError(t, f.SetAppProps(&AppProperties{
		Application:       "Microsoft Excel",
		ScaleCrop:         true,
		DocSecurity:       3,
		Company:           "Company Name",
		LinksUpToDate:     true,
		HyperlinksChanged: true,
		AppVersion:        "16.0000",
	}))
	assert.NoError(t, f.SaveAs(filepath.Join("test", "TestSetAppProps.xlsx")))
	f.Pkg.Store(defaultXMLPathDocPropsApp, nil)
	assert.NoError(t, f.SetAppProps(&AppProperties{}))
	assert.NoError(t, f.Close())

	// Test unsupported charset
	f = NewFile()
	f.Pkg.Store(defaultXMLPathDocPropsApp, MacintoshCyrillicCharset)
	assert.EqualError(t, f.SetAppProps(&AppProperties{}), "XML syntax error on line 1: invalid UTF-8")
}

func TestGetAppProps(t *testing.T) {
	f, err := OpenFile(filepath.Join("test", "Book1.xlsx"))
	if !assert.NoError(t, err) {
		t.FailNow()
	}
	props, err := f.GetAppProps()
	assert.NoError(t, err)
	assert.Equal(t, props.Application, "Microsoft Macintosh Excel")
	f.Pkg.Store(defaultXMLPathDocPropsApp, nil)
	_, err = f.GetAppProps()
	assert.NoError(t, err)
	assert.NoError(t, f.Close())

	// Test get application properties with unsupported charset
	f = NewFile()
	f.Pkg.Store(defaultXMLPathDocPropsApp, MacintoshCyrillicCharset)
	_, err = f.GetAppProps()
	assert.EqualError(t, err, "XML syntax error on line 1: invalid UTF-8")
}

func TestSetDocProps(t *testing.T) {
	f, err := OpenFile(filepath.Join("test", "Book1.xlsx"))
	if !assert.NoError(t, err) {
		t.FailNow()
	}
	assert.NoError(t, f.SetDocProps(&DocProperties{
		Category:       "category",
		ContentStatus:  "Draft",
		Created:        "2019-06-04T22:00:10Z",
		Creator:        "Go Excelize",
		Description:    "This file created by Go Excelize",
		Identifier:     "xlsx",
		Keywords:       "Spreadsheet",
		LastModifiedBy: "Go Author",
		Modified:       "2019-06-04T22:00:10Z",
		Revision:       "0",
		Subject:        "Test Subject",
		Title:          "Test Title",
		Language:       "en-US",
		Version:        "1.0.0",
	}))
	assert.NoError(t, f.SaveAs(filepath.Join("test", "TestSetDocProps.xlsx")))
	f.Pkg.Store(defaultXMLPathDocPropsCore, nil)
	assert.NoError(t, f.SetDocProps(&DocProperties{}))
	assert.NoError(t, f.Close())

	// Test unsupported charset
	f = NewFile()
	f.Pkg.Store(defaultXMLPathDocPropsCore, MacintoshCyrillicCharset)
	assert.EqualError(t, f.SetDocProps(&DocProperties{}), "XML syntax error on line 1: invalid UTF-8")
}

func TestGetDocProps(t *testing.T) {
	f, err := OpenFile(filepath.Join("test", "Book1.xlsx"))
	if !assert.NoError(t, err) {
		t.FailNow()
	}
	props, err := f.GetDocProps()
	assert.NoError(t, err)
	assert.Equal(t, props.Creator, "Microsoft Office User")
	f.Pkg.Store(defaultXMLPathDocPropsCore, nil)
	_, err = f.GetDocProps()
	assert.NoError(t, err)
	assert.NoError(t, f.Close())

	// Test get workbook properties with unsupported charset
	f = NewFile()
	f.Pkg.Store(defaultXMLPathDocPropsCore, MacintoshCyrillicCharset)
	_, err = f.GetDocProps()
	assert.EqualError(t, err, "XML syntax error on line 1: invalid UTF-8")
}

func TestCustomProps(t *testing.T) {
	f := NewFile()
	expected := []CustomProperty{
		{Name: "Text Prop", Value: "text"},
		{Name: "Boolean Prop 1", Value: true},
		{Name: "Boolean Prop 2", Value: false},
		{Name: "Number Prop 1", Value: -123.456},
		{Name: "Number Prop 2", Value: int32(1)},
		{Name: "Date Prop", Value: time.Date(2021, time.September, 11, 0, 0, 0, 0, time.UTC)},
	}
	for _, prop := range expected {
		assert.NoError(t, f.SetCustomProps(prop))
	}
	props, err := f.GetCustomProps()
	assert.NoError(t, err)
	assert.Equal(t, expected, props)

	// Test delete custom property
	assert.NoError(t, f.SetCustomProps(CustomProperty{Name: "Boolean Prop 1", Value: nil}))
	props, err = f.GetCustomProps()
	assert.NoError(t, err)
	expected = slices.Delete(expected, 1, 2)
	assert.Equal(t, expected, props)

	// Test change custom property value data type
	assert.NoError(t, f.SetCustomProps(CustomProperty{Name: "Boolean Prop 2", Value: "true"}))
	props, err = f.GetCustomProps()
	assert.NoError(t, err)
	assert.Equal(t, props[1].Value, "true")

	// Test set custom property with unsupported value data type
	assert.Equal(t, ErrParameterInvalid, f.SetCustomProps(CustomProperty{Name: "Boolean Prop 2", Value: 1}))

	assert.NoError(t, f.SaveAs(filepath.Join("test", "TestSetCustomProps.xlsx")))
	assert.NoError(t, f.Close())

	// Test set custom property without property name
	f = NewFile()
	assert.Equal(t, ErrParameterInvalid, f.SetCustomProps(CustomProperty{}))

	// Test set custom property with unsupported charset
	f.Pkg.Store(defaultXMLPathDocPropsCustom, MacintoshCyrillicCharset)
	assert.EqualError(t, f.SetCustomProps(CustomProperty{Name: "Prop"}), "XML syntax error on line 1: invalid UTF-8")

	// Test get custom property with unsupported charset
	_, err = f.GetCustomProps()
	assert.EqualError(t, err, "XML syntax error on line 1: invalid UTF-8")

	// Test set custom property with unsupported charset content types
	f = NewFile()
	f.ContentTypes = nil
	f.Pkg.Store(defaultXMLPathContentTypes, MacintoshCyrillicCharset)
	assert.EqualError(t, f.SetCustomProps(CustomProperty{Name: "Prop"}), "XML syntax error on line 1: invalid UTF-8")

	// Test get custom property with unsupported charset
	f.Pkg.Store(defaultXMLPathDocPropsCustom, []byte(fmt.Sprintf(`<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/custom-properties" xmlns:vt="%s"><property fmtid="%s" pid="2" name="Prop"><vt:filetime>x</vt:filetime></property></Properties>`, NameSpaceDocumentPropertiesVariantTypes, EXtURICustomPropertyFmtID)))
	_, err = f.GetCustomProps()
	assert.EqualError(t, err, "parsing time \"x\" as \"2006-01-02T15:04:05Z07:00\": cannot parse \"x\" as \"2006\"")

	// Test get custom property with unsupported value data type
	f.Pkg.Store(defaultXMLPathDocPropsCustom, []byte(fmt.Sprintf(`<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/custom-properties" xmlns:vt="%s"><property fmtid="%s" pid="2" name="Prop"><vt:cy></vt:cy></property></Properties>`, NameSpaceDocumentPropertiesVariantTypes, EXtURICustomPropertyFmtID)))
	props, err = f.GetCustomProps()
	assert.Equal(t, []CustomProperty{{Name: "Prop"}}, props)
	assert.NoError(t, err)
	assert.NoError(t, f.Close())
}
